---
title: 常见面试知识点
---

## vue2 和 vue3 的区别

一、性能提升

1. 基于Proxy的新响应式系统（数据劫持优化）

由原来的Object.defineProperty的getter 和setter，改成了ES6 Proxy 作为其观察机制（准确说是 Proxy 配合 Reflect，Reflect提供了一些操作Object对象的方法），初始化时无需递归遍历数据，初始化效率更高，而且也可以监控数组。速度加倍，节省了一半内存开销。

2. 虚拟DOM重写

虚拟DOM静态属性缓存，避免重复patch。内存换时间。

3. Diff算法优化

增加了静态标记flag。标记和提升所有静态根节点，diff 的时候只⽐较动态节点内容。

4. 静态提升（hoistStatic）

Vue2中无论元素是否参与更新，每次都会重新创建（createVNode），然后再渲染（Vue2 中的虚拟dom节点是进⾏全量的更新）。

在Vue3中使用了静态提升后，对于静态不需要发生变化的元素，只会被创建一次，静态节点都被提升到 render ⽅法之外，在渲染时直接复用即可。（**静态提升避免了静态元素节点频繁重复创建**）

5. 体积更小

vue3整个源码体积相对减少，优化了打包方法，引入tree-shaking，按需编译，避免打包无用模块（例如只打包用到的ref,reactive,components等），使得打包后的bundle的体积更小，提升了运行效率。（通过摇树优化核⼼库体积，减少不必要的代码量）

二、开发体验提升

1. 用 Ts 完全重写

基于typescipt编写，可以享受到类型提示。对Ts支持更好。

编辑器可提供强有力的类型检查和错误提示。

2. Compositon Api 的支持

compositon Api 可以解决业务分离问题，使代码有更好的复用性。

同时，也方便后续的维护和管理，setup() 的出现，使得相关的业务代码得以集中起来，方便查找和维护。我们可以把不同的业务代码进行逻辑抽离，比如使用hooks形式，更容易维护。而Vue2不同的业务代码都混杂在options中，不便管理。
